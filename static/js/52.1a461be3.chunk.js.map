{"version":3,"sources":["views/Nft/market/index.tsx","state/nftMarket/hooks.ts"],"names":["Home","lazy","NftProfile","Collection","Collections","Activity","Market","account","useWeb3React","initializationState","useGetNFTInitializationState","useFetchCollections","NFTMarketInitializationState","INITIALIZED","exact","path","nftsBaseUrl","to","toLowerCase","dispatch","useAppDispatch","useEffect","fetchCollections","useFetchCollection","collectionAddress","fetchCollection","useFetchByGladiatorCollectibleIdAndUpdate","bunnyId","useSelector","state","nftMarket","data","loadingState","latestGladiatorCollectiblesUpdateAt","isUpdatingGladiatorCollectibles","existingGladiatorCollectibleInState","useGetAllGladiatorCollectibleByGladiatorCollectibleId","existingTokensWithGladiatorCollectibleId","map","nft","tokenId","allGladiatorCollectibles","useNftsFromCollection","gladiatorCollectiblesAddress","allExistingPBTokenIds","firstGladiatorCollectible","length","existingMetadata","useMemo","name","description","collection","collectionName","image","fetchMoreGladiatorCollectibles","orderDirection","fetchNewPBAndUpdateExisting","useLoadingState","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","isAddress","nfts","filter","attributes","value","marketData","isTradable","useUserNfts","user","useGetNftFilters","collectionFilter","filters","activeFilters","useGetNftFilterLoadingState","FetchStatus","Idle","useGetNftOrdering","ordering","field","direction","useGetNftShowOnlyOnSale","showOnlyOnSale","useGetNftActivityFilters","activityFilters","typeFilters","collectionFilters"],"mappings":"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","file":"static/js/52.1a461be3.chunk.js","sourcesContent":["import React, { lazy } from 'react'\nimport { Redirect, Route } from 'react-router-dom'\nimport { useWeb3React } from '@web3-react/core'\nimport { useFetchCollections, useGetNFTInitializationState } from 'state/nftMarket/hooks'\nimport PageLoader from 'components/Loader/PageLoader'\nimport { NFTMarketInitializationState } from 'state/nftMarket/types'\nimport { nftsBaseUrl } from './constants'\n\nconst Home = lazy(() => import('./Home'))\nconst NftProfile = lazy(() => import('./Profile'))\nconst Collection = lazy(() => import('./Collection'))\nconst Collections = lazy(() => import('./Collections'))\nconst Activity = lazy(() => import('./Activity'))\n\nconst Market = () => {\n  const { account } = useWeb3React()\n  const initializationState = useGetNFTInitializationState()\n\n  useFetchCollections()\n\n  if (initializationState !== NFTMarketInitializationState.INITIALIZED) {\n    return <PageLoader />\n  }\n\n  return (\n    <>\n      <Route exact path={nftsBaseUrl}>\n        <Home />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/collections`}>\n        <Collections />\n      </Route>\n      <Route path={`${nftsBaseUrl}/activity`}>\n        <Activity />\n      </Route>\n      <Route path={`${nftsBaseUrl}/collections/:collectionAddress`}>\n        <Collection />\n      </Route>\n      <Route path={`${nftsBaseUrl}/profile/:accountAddress?`}>\n        <NftProfile />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/profile`}>\n        <Redirect to={`${nftsBaseUrl}/profile/${account?.toLowerCase() || ''}`} />\n      </Route>\n    </>\n  )\n}\n\nexport default Market\n","import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { gladiatorCollectiblesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport { FetchStatus } from 'config/constants/types'\nimport { fetchCollection, fetchCollections, fetchNewPBAndUpdateExisting } from './reducer'\nimport { State } from '../types'\nimport { NftActivityFilter, NftFilter, NftToken, UserNftsState } from './types'\n\nconst MAX_GEN0_ID = 4\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n  }, [dispatch])\n}\n\nexport const useFetchCollection = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollection(collectionAddress))\n  }, [dispatch, collectionAddress])\n}\n\n// Returns a function that fetches more NFTs for specified bunny id\n// as well as updating existing PB NFTs in state\n// Note: GladiatorCollectible specific\nexport const useFetchByGladiatorCollectibleIdAndUpdate = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const { latestGladiatorCollectiblesUpdateAt, isUpdatingGladiatorCollectibles } = useSelector(\n    (state: State) => state.nftMarket.data.loadingState,\n  )\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingGladiatorCollectibleInState = useGetAllGladiatorCollectibleByGladiatorCollectibleId(bunnyId)\n  const existingTokensWithGladiatorCollectibleId = existingGladiatorCollectibleInState ? existingGladiatorCollectibleInState.map((nft) => nft.tokenId) : []\n\n  const allGladiatorCollectibles = useNftsFromCollection(gladiatorCollectiblesAddress)\n  const allExistingPBTokenIds = allGladiatorCollectibles ? allGladiatorCollectibles.map((nft) => nft.tokenId) : []\n\n  const firstGladiatorCollectible = existingGladiatorCollectibleInState.length > 0 ? existingGladiatorCollectibleInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstGladiatorCollectible\n      ? {\n          name: firstGladiatorCollectible.name,\n          description: firstGladiatorCollectible.description,\n          collection: { name: firstGladiatorCollectible.collectionName },\n          image: firstGladiatorCollectible.image,\n        }\n      : null\n  }, [firstGladiatorCollectible])\n\n  // This fetches more bunnies when called\n  const fetchMoreGladiatorCollectibles = (orderDirection: 'asc' | 'desc') => {\n    dispatch(\n      fetchNewPBAndUpdateExisting({\n        bunnyId,\n        existingTokensWithGladiatorCollectibleId,\n        allExistingPBTokenIds,\n        existingMetadata,\n        orderDirection,\n      }),\n    )\n  }\n\n  return { isUpdatingGladiatorCollectibles, latestGladiatorCollectiblesUpdateAt, fetchMoreGladiatorCollectibles }\n}\n\nexport const useLoadingState = () => {\n  return useSelector((state: State) => state.nftMarket.data.loadingState)\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllGladiatorCollectibleByGladiatorCollectibleId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[gladiatorCollectiblesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n\nexport const useHasGen0Nfts = (): boolean => {\n  const userNfts = useSelector((state: State) => state.nftMarket.data.user)\n  return userNfts.nfts.some((nft) => nft.attributes && Number(nft.attributes[0]?.value) <= MAX_GEN0_ID)\n}\n\nexport const useGetNftFilters = (collectionAddress: string) => {\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\n  return collectionFilter ? collectionFilter.activeFilters : {}\n}\n\nexport const useGetNftFilterLoadingState = (collectionAddress: string) => {\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\n  return collectionFilter ? collectionFilter.loadingState : FetchStatus.Idle\n}\n\nexport const useGetNftOrdering = (collectionAddress: string) => {\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\n  return collectionFilter ? collectionFilter.ordering : { field: 'currentAskPrice', direction: 'asc' as 'asc' | 'desc' }\n}\n\nexport const useGetNftShowOnlyOnSale = (collectionAddress: string) => {\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\n  return collectionFilter ? collectionFilter.showOnlyOnSale : true\n}\n\nexport const useGetNftActivityFilters = (collectionAddress: string) => {\n  const collectionFilter: NftActivityFilter = useSelector(\n    (state: State) => state.nftMarket.data.activityFilters[collectionAddress],\n  )\n  return collectionFilter || { typeFilters: [], collectionFilters: [] }\n}\n"],"sourceRoot":""}